#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright © 2013 Martin Ueding <dev@martin-ueding.de>

import argparse
import matplotlib.pyplot as pl
import numpy as np
import scipy.optimize as op

__docformat__ = "restructuredtext en"

def main():
    options = _parse_args()

    a_data = np.genfromtxt("a.csv", delimiter="\t")

    dunkelstrom = 0.0082

    U = a_data[:,1] - dunkelstrom
    phi = a_data[:,0]


    def malus(phi, phi0, I0, baseline):
        return I0 * (np.cos((phi - phi0)*np.pi/180))**2 + baseline

    popt, pconv = op.curve_fit(malus, phi, U, p0=[90, 2.1, 0.35])

    print "φ₀ = {:.3f} ± {:.3f}, U₀ = {:.3f} ± {:.3f}, U₁ = {:.3f} ± {:.3f}".format(
        popt[0],
        np.sqrt(pconv.diagonal())[0],
        popt[1],
        np.sqrt(pconv.diagonal())[1],
        popt[2],
        np.sqrt(pconv.diagonal())[2],
    )

    x = np.linspace(min(phi), max(phi), 100)
    y = malus(x, *popt)

    I_max_val = popt[1] + popt[2]
    I_min_val = popt[2]

    I_max_err = np.sqrt(
        np.sqrt(pconv.diagonal())[1]**2
        + np.sqrt(pconv.diagonal())[2]**2
    )
    I_min_err = np.sqrt(pconv.diagonal())[2]

    PG_val = (I_max_val - I_min_val) / (I_max_val + I_min_val)
    PG_err = np.sqrt(
        ((-((I_max_val - I_min_val)/(I_max_val + I_min_val)**2) + 1/(I_max_val + I_min_val)) * I_max_err)**2
        +((-((I_max_val - I_min_val)/(I_max_val + I_min_val)**2) - 1/(I_max_val + I_min_val) * I_min_err)**2)
    )

    print "I_max = {:.3f} ± {:.3f}, I_min = {:.3f} ± {:.3f}, PG = {:.3f} ± {:.3f}".format(
        I_max_val,
        I_max_err,
        I_min_val,
        I_min_err,
        PG_val,
        PG_err,
    )
    
    pl.errorbar(phi, U, xerr=1, yerr=0.01, label="Messdaten", linestyle="none",
                color="black")
    pl.plot(x, y, label="Fit", color="black")
    pl.grid(True)
    pl.legend(loc="best")
    pl.title(u"Intensitätstransmission nach zweitem Polfilter")
    pl.xlabel(ur"$\phi / ^\circ$")
    pl.ylabel(ur"$U / \mathrm{V}$")
    pl.savefig("a.pdf")
    pl.clf()

    ####

    b = {}
    diff = {}

    wavelengths = [694.0, 620.0, 568.0, 520.0, 488.0, 458.0, 430.0]

    for wavelength in wavelengths:
        b[wavelength] = np.genfromtxt("b-{0}.csv".format(int(wavelength)), delimiter="\t")
        phi0 = b[wavelength][:,0]
        phi = b[wavelength][:,1]
        diff[wavelength] = phi0 - phi

    plot_x = (np.array(wavelengths)/10**3)**(-2)
    plot_y = np.array([np.mean(diff[wavelength]) for wavelength in wavelengths])
    plot_y_err = np.array(np.sqrt([np.std(diff[wavelength]) for wavelength in wavelengths]))

    def rotation(invers, A, B):
        return B + invers*A

    popt, pconv = op.curve_fit(rotation, plot_x, plot_y, sigma=plot_y_err)

    col = np.column_stack([plot_x, plot_y, plot_y_err])
    np.savetxt("test.txt", col)

    print popt, pconv

    x = np.linspace(min(plot_x), max(plot_x), 100)
    y = rotation(x, *popt)

    pl.errorbar(plot_x, plot_y, yerr=plot_y_err, linestyle="none",
                color="black", marker="+", label="Messdaten")
    pl.plot(x, y, label="Fit", color="black")
    pl.title(u"Drehwinkel als Funktion der Wellenlänge")
    pl.xlabel(ur"$\lambda^{-2}/\mathrm{\mu m^{-2}}$")
    pl.ylabel(ur"$\phi - \phi_0 / ^\circ$")
    pl.grid(True)
    pl.savefig("b.pdf")
    pl.clf()


def _parse_args():
    """
    Parses the command line arguments.

    :return: Namespace with arguments.
    :rtype: Namespace
    """
    parser = argparse.ArgumentParser(description="")
    #parser.add_argument("args", metavar="N", type=str, nargs="*", help="Positional arguments.")
    #parser.add_argument("", dest="", type="", default=, help=)
    #parser.add_argument("--version", action="version", version="<the version>")

    return parser.parse_args()


if __name__ == "__main__":
    main()
