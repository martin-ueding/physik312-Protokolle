#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright © 2013 Martin Ueding <dev@martin-ueding.de>

import argparse
import matplotlib.pyplot as pl
import numpy as np
import scipy.optimize as op

__docformat__ = "restructuredtext en"

def main():
    options = _parse_args()

    a_data = np.recfromtxt("a.csv", delimiter="\t", dtype=[("phi", "f"), ("U", "f")])

    dunkelstrom = 0.0082

    a_data.U -= dunkelstrom

    def malus(phi, phi0, I0, baseline):
        return I0 * (np.cos((phi - phi0)*np.pi/180))**2 + baseline

    popt, pconv = op.curve_fit(malus, a_data.phi, a_data.U, p0=[90, 2.1, 0.35])

    print popt, pconv

    x = np.linspace(min(a_data.phi), max(a_data.phi), 100)
    y = malus(x, *popt)

    I_max_val = popt[1]
    I_min_val = popt[2]

    #I_max_err = np.sqrt(pconv.diagonal())[1]
    #I_min_err = np.sqrt(pconv.diagonal())[2]

    PG_val = (I_max_val - I_min_val) / (I_max_val + I_min_val)

    print "I_max = {:.3f} ± {:.3f}, I_min = {:.3f} ± {:.3f}, PG = {:.3f} ± {:.3f}".format(
        I_max_val,
        0,#I_max_err,
        I_min_val,
        0,#I_min_err,
        PG_val,
        0,# PG_err,
    )
    
    pl.errorbar(a_data.phi, a_data.U, xerr=1, yerr=0.01, label="Messdaten",
                linestyle="none", color="black")
    pl.plot(x, y, label="Fit", color="black")
    pl.grid(True)
    pl.legend(loc="best")
    pl.title(u"Intensitätstransmission nach zweitem Polfilter")
    pl.xlabel(ur"$\phi / ^\circ$")
    pl.ylabel(ur"$U / \mathrm{V}$")
    pl.savefig("a.pdf")
    pl.clf()

    b = {}
    diff = {}

    wavelengths = [694, 620, 568, 520, 488, 458, 430]

    for wavelength in wavelengths:
        b[wavelength] = np.recfromtxt("b-{0}.csv".format(wavelength), delimiter="\t", dtype=[("phi0", "f"), ("phi", "f")])
        diff[wavelength] = b[wavelength].phi0 - b[wavelength].phi

    b_data = np.zeros(len(wavelengths), dtype=[("wavelength", "f"), ("diff", "f"), ("err", "f")])

    b_data["wavelength"] = np.array(wavelengths)
    diffs = np.array([np.mean(diff[wavelength]) for wavelength in wavelengths])
    errs = np.array(np.sqrt([np.std(diff[wavelength]) for wavelength in wavelengths]))
    b_data["diff"] = diffs
    b_data["err"] = errs

    plot_x = (b_data["wavelength"]/10**3)**(-2)
    plot_y = b_data["diff"]
    plot_y_err = b_data["err"]

    def rotation(invers, A, B):
        return B + invers*A

    popt, pconv = op.curve_fit(rotation, plot_x, plot_y, sigma=plot_y_err)

    col = np.column_stack([plot_x, plot_y, plot_y_err])
    np.savetxt("test.txt", col)

    print popt, pconv

    x = np.linspace(min(plot_x), max(plot_x), 100)
    y = rotation(x, *popt)

    pl.errorbar(plot_x, plot_y, yerr=plot_y_err, linestyle="none",
                color="black", marker="+", label="Messdaten")
    pl.plot(x, y, label="Fit", color="black")
    pl.title(u"Drehwinkel als Funktion der Wellenlänge")
    pl.xlabel(ur"$\lambda^{-2}/\mathrm{\mu m^{-2}}$")
    pl.ylabel(ur"$\phi - \phi_0 / ^\circ$")
    pl.grid(True)
    pl.savefig("b.pdf")
    pl.clf()


def _parse_args():
    """
    Parses the command line arguments.

    :return: Namespace with arguments.
    :rtype: Namespace
    """
    parser = argparse.ArgumentParser(description="")
    #parser.add_argument("args", metavar="N", type=str, nargs="*", help="Positional arguments.")
    #parser.add_argument("", dest="", type="", default=, help=)
    #parser.add_argument("--version", action="version", version="<the version>")

    return parser.parse_args()


if __name__ == "__main__":
    main()
